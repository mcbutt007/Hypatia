package us.spotco.malwarescanner;

import android.os.AsyncTask;
import android.widget.TextView;

import io.ipfs.api.IPFS;
import io.ipfs.api.NamedStreamable;
import io.ipfs.api.WriteFilesArgs;
import io.ipfs.multiaddr.MultiAddress;
import io.ipfs.multihash.Multihash;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

class IPFSClient extends AsyncTask<Void, String, Void> {
    private TextView displayTextView;

    public IPFSClient(TextView displayTextView) {
        this.displayTextView = displayTextView;
    }

    @Override
    protected Void doInBackground(Void... voids) {
        IPFS ipfs = new IPFS(new MultiAddress("/ip4/127.0.0.1/tcp/5001"));
        try {
            publishProgress("remove 'my' directory to clean up from a previous run...");
            // remove 'my' directory to clean up from a previous run
            ipfs.files.rm("/my", true, true);

            // To create a new directory nested under others that don't yet exist, you need to explicitly set the value of parents to true
            ipfs.files.mkdir("/my/directory/example", true);

            // Check directory status
            String directoryPath = "/my/directory/example";
            Map exampleDirectory = ipfs.files.stat(directoryPath);
            //{Hash=QmV1a2QoUnB9fPzjZd1GunGR53isuhcWWNCS5Bg3mJyv8N, Size=0, CumulativeSize=57, Blocks=1, Type=directory}

            // Add a file
            String contents = "hello world!";
            String filename = "hello.txt";
            String filePath = directoryPath + "/" + filename;
            NamedStreamable ns = new NamedStreamable.ByteArrayWrapper(filename, contents.getBytes());
            ipfs.files.write(filePath, ns, true, true);

            // Read contents of a file
            String fileContents = new String(ipfs.files.read(filePath));
            publishProgress(fileContents);

            // Write a file using builder pattern
            String ipfsFilename = "ipfs.txt";
            String fullIpfsPath = directoryPath + "/" + ipfsFilename;
            NamedStreamable ipfsFile = new NamedStreamable.ByteArrayWrapper(ipfsFilename, "ipfs says hello".getBytes());
            WriteFilesArgs args = WriteFilesArgs.Builder.newInstance()
                    .setCreate()
                    .setParents()
                    .build();
            ipfs.files.write(fullIpfsPath, ipfsFile, args);

            // List directory contents
            List<Map> ls = ipfs.files.ls(directoryPath);
            for(Map entry : ls) {
                publishProgress((String) entry.get("Name"));
            }

            // Copy file to another directory
            String copyDirectoryPath = "/my/copy/";
            ipfs.files.cp(filePath, copyDirectoryPath + filename, true);
            ls = ipfs.files.ls(copyDirectoryPath);
            for(Map entry : ls) {
                publishProgress((String) entry.get("Name"));
            }

            // Move file to another directory
            String duplicateDirectoryPath = "/my/duplicate/";
            ipfs.files.mkdir(duplicateDirectoryPath, false);
            ipfs.files.mv(copyDirectoryPath + filename, duplicateDirectoryPath + filename);
            ls = ipfs.files.ls(duplicateDirectoryPath);
            for(Map entry : ls) {
                publishProgress((String) entry.get("Name"));
            }

            // Remove a directory
            ipfs.files.rm(copyDirectoryPath, true, true);
            ls = ipfs.files.ls("/my");
            for(Map entry : ls) {
                publishProgress((String) entry.get("Name"));
            }
        } catch (IOException e) {
            // Error handling
            e.printStackTrace();
        }
        return null;
    }
    protected void onProgressUpdate(String... progress) {
        displayTextView.append(progress[0] + "\n");
    }
}
