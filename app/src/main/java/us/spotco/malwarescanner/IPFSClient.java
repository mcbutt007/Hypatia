package us.spotco.malwarescanner;

import android.content.Context;
import android.os.AsyncTask;
import android.widget.TextView;

import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.net.HttpURLConnection;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.text.DateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import io.ipfs.api.IPFS;
import io.ipfs.cid.Cid;
import io.ipfs.multiaddr.MultiAddress;
import io.ipfs.multihash.Multihash;

class IPFSClient {
    private static TextView displayTextView;
    private static final DateFormat dateFormat = DateFormat.getDateInstance();
    private static File ipfsPath = null;
    public String ipfsGatewayUrl = "http://127.0.0.1:8080/ipfs/";


    public IPFSClient(TextView displayTextView) {
        this.displayTextView = displayTextView;
    }
    public Void UpdateDBUsingIPFS(Context context) {
        ipfsPath = new File(context.getFilesDir() + "/ipfs");
        ipfsPath.mkdir();

        List<SignatureFromBlockchain> signatures = readJsonFromFile(context, "signatures.json");

        displayTextView.append("Downloading signatures from IPFS gateway" + "\n");

        if (signatures != null) {
            for (SignatureFromBlockchain signature : signatures) {
                new IPFSGatewayDownloader().executeOnExecutor(Utils.getThreadPoolExecutor(), ipfsGatewayUrl + signature.IPFS_CID, ipfsPath + "/" + signature.SigName + ".bin", ipfsGatewayUrl, signature.SigName , signature.Timestamp);
            }
        }
        return null;
    }
    public static class IPFSGatewayDownloader extends AsyncTask<Object, String, String> {

        protected String doInBackground(Object... objects) {
//            IPFS ipfs = new IPFS(new MultiAddress("/ip4/127.0.0.1/tcp/5001"));

            String url = (String) objects[0];
            String name = (String) objects[3];
            File out = new File((String) objects[1]);
            File outNew = new File(objects[1] + ".new");
            String baseURL = (String) objects[2];
            Long timestamp = (Long) objects[4];
            try {
                if (outNew.exists()) {
                    outNew.delete();
                }
                HttpURLConnection connection;

                connection = (HttpURLConnection) new URL(url).openConnection();

                connection.setConnectTimeout(90000);
                connection.setReadTimeout(30000);
                connection.addRequestProperty("User-Agent", "Hypatia");
                String lastModifiedLocal = "";
                if (out.exists()) {
                    connection.setIfModifiedSince(out.lastModified());
                    lastModifiedLocal = Utils.getContext().getString(R.string.main_database_not_modified_since, dateFormat.format(new Date(out.lastModified())));
                }
                connection.connect();
                String lastModifiedServer = dateFormat.format(new Date(timestamp * 1000L));
                int res = connection.getResponseCode();
                if (res != 304) {
                    if (res == 200) {
                        FileOutputStream fileOutputStream = new FileOutputStream(outNew);

                        final byte[] data = new byte[1024];
                        int count;
                        while ((count = connection.getInputStream().read(data, 0, 1024)) != -1) {
                            fileOutputStream.write(data, 0, count);
                        }

                        fileOutputStream.close();
                        outNew.renameTo(out); //Move the new file into place

                        publishProgress(name
                                + "\n\t" + Utils.getContext().getString(R.string.main_database_download_success)
                                + "\n\t" + Utils.getContext().getString(R.string.main_database_released_on, lastModifiedServer) + "\n");
                    } else {
                        publishProgress(name
                                + "\n\t" + Utils.getContext().getString(R.string.main_database_download_error, String.valueOf(res)) + "\n");
                    }
                } else {
                    publishProgress(name
                            + "\n\t" + Utils.getContext().getString(R.string.main_database_not_changed) + " " + lastModifiedLocal + "\n");
                }
                connection.disconnect();
            } catch (Exception e) {
                e.printStackTrace();
                if (outNew.exists()) {
                    outNew.delete();
                }
                publishProgress(url.replaceAll(baseURL, "")
                        + "\n" + Utils.getContext().getString(R.string.main_database_download_error_logcat) + "\n");
            }
            return null;
        }

        protected void onProgressUpdate(String... progress) {
            displayTextView.append(progress[0] + "\n");
        }
        protected void onPostExecute(String result) {

        }
    }
    public static List<SignatureFromBlockchain> readJsonFromFile(Context context, String filename) {
        try {
            // 1. Get file path from app's internal storage
            File file = new File(context.getFilesDir(), filename);

            // 2. Read file content
            BufferedReader reader = new BufferedReader(new FileReader(file));
            StringBuilder jsonBuilder = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                jsonBuilder.append(line);
            }
            reader.close();

            // 3. Parse JSON using Gson
            Type signatureListType = new TypeToken<List<SignatureFromBlockchain>>() {}.getType();
            return new Gson().fromJson(jsonBuilder.toString(), signatureListType);
        } catch (IOException e) {
            e.printStackTrace();
            // Handle exceptions appropriately (e.g., show error message to the user)
        }
        return null; // Or return an empty list
    }
}
