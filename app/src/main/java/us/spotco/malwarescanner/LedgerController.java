package us.spotco.malwarescanner;

import android.content.Context;
import android.content.res.Resources;
import android.os.AsyncTask;
import android.util.Log;
import android.widget.TextView;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;

import org.hyperledger.fabric.client.Contract;
import org.hyperledger.fabric.client.Gateway;
import org.hyperledger.fabric.client.GatewayException;
import org.hyperledger.fabric.client.identity.Identities;
import org.hyperledger.fabric.client.identity.Identity;
import org.hyperledger.fabric.client.identity.Signer;
import org.hyperledger.fabric.client.identity.Signers;
import org.hyperledger.fabric.client.identity.X509Identity;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.InvalidKeyException;
import java.security.cert.CertificateException;
import java.util.concurrent.TimeUnit;

import io.grpc.Grpc;
import io.grpc.ManagedChannel;
import io.grpc.TlsChannelCredentials;
public class LedgerController {
    private static final String MSP_ID = "Org1MSP";
    private static final String CHANNEL_NAME = "mychannel";
    private static final String CHAINCODE_NAME = "basic";

    private static final Path CRYPTO_PATH = Paths.get("crypto");
    private static final Path CERT_DIR_PATH = CRYPTO_PATH.resolve(Paths.get("users/User1@org1.example.com/msp/signcerts/cert.pem"));
    private static final Path KEY_DIR_PATH = CRYPTO_PATH.resolve(Paths.get("users/User1@org1.example.com/msp/keystore/a633924bdd7104929921492b759a790c5e8ba25367becd87cf1c1667bb68b36e_sk"));
    private static final Path TLS_CERT_PATH = CRYPTO_PATH.resolve(Paths.get("peers/peer0.org1.example.com/tls/ca.crt"));

    private static final String PEER_ENDPOINT = "192.168.1.207:7051";
    private static final String OVERRIDE_AUTH = "peer0.org1.example.com";

    private Contract contract;
    private final Gson gson = new GsonBuilder().setPrettyPrinting().create();
    private static final String TAG = "Hyperledger";
    private Context context;

    private TextView displayTextView;

    private ManagedChannel channel = null;

    public void handleGateway(Context context, TextView displayTextView) throws Exception {
        this.displayTextView = displayTextView;
        this.context = context;
        channel = newGrpcConnection();

        Gateway.Builder builder = Gateway.newInstance().identity(newIdentity()).signer(newSigner()).connection(channel)
                .evaluateOptions(options -> options.withDeadlineAfter(5, TimeUnit.SECONDS))
                .endorseOptions(options -> options.withDeadlineAfter(15, TimeUnit.SECONDS))
                .submitOptions(options -> options.withDeadlineAfter(5, TimeUnit.SECONDS))
                .commitStatusOptions(options -> options.withDeadlineAfter(1, TimeUnit.MINUTES));

        try (Gateway gateway = builder.connect()) {
            HyperledgerGateway hyperledgerGateway = new HyperledgerGateway(gateway);
            hyperledgerGateway.executeOnExecutor(Utils.getThreadPoolExecutor());;
        } finally {
            // channel.shutdownNow().awaitTermination(5, TimeUnit.SECONDS);
        }
    }
    private ManagedChannel newGrpcConnection() throws IOException {
        var credentials = TlsChannelCredentials.newBuilder()
                .trustManager(convertStringToInputStream(context.getString(R.string.tls_cert)))
                .build();
        return Grpc.newChannelBuilder(PEER_ENDPOINT, credentials)
                .overrideAuthority(OVERRIDE_AUTH)
                .build();
    }

    private Identity newIdentity() throws IOException, CertificateException {
        try (var certReader = convertStringToBufferedReader(context.getString(R.string.cert))) {
            var certificate = Identities.readX509Certificate(certReader);
            return new X509Identity(MSP_ID, certificate);
        }
    }

    private Signer newSigner() throws IOException, InvalidKeyException {
        try (var keyReader = convertStringToBufferedReader(context.getString(R.string.key))) {
            var privateKey = Identities.readPrivateKey(keyReader);
            return Signers.newPrivateKeySigner(privateKey);
        }
    }

    private class HyperledgerGateway extends AsyncTask<Void, String, Void> {

        int points = 0;

        public HyperledgerGateway(Gateway gateway) {
            var network = gateway.getNetwork(CHANNEL_NAME);
            contract = network.getContract(CHAINCODE_NAME);
        }

        protected Void doInBackground(Void... params) {
            try {

                GetOrgsVoted();
                publishProgress("\n");
                GetPoints();
                publishProgress("\n");
                if (points < 2) {
                    publishProgress("*** Approval points not enough: " + this.points + "\n");
                } else {
                    GetAllSignatures();
                }
                channel.shutdownNow().awaitTermination(5, TimeUnit.SECONDS);
            } catch (GatewayException | IOException e) {
                Log.e("BackgroundTask", "Error occurred", e);
            } catch (InterruptedException | JSONException e) {
                throw new RuntimeException(e);
            }
            return null;
        }
        protected void onProgressUpdate(String... progress) {
            displayTextView.append(progress[0]);
        }

        private void GetAllSignatures() throws GatewayException, IOException {
            publishProgress("\n--> Evaluate Transaction: GetAllSignatures, function returns all the current virus signatures on the ledger\n");

            var result = contract.evaluateTransaction("GetAllSignatures");

            publishProgress("*** Result: " + prettyJson(result) + "\n");

            saveResult(result);
        }
        private void GetPoints() throws GatewayException, JSONException {

            var result = contract.evaluateTransaction("CountVotes");

            JSONObject jsonObject = new JSONObject(prettyJson(result));
            this.points = jsonObject.getInt("approve");
        }

        private void GetOrgsVoted() throws GatewayException {

            var result = contract.evaluateTransaction("ListOrgsVoted");

            publishProgress("*** Orgs Voted Result: " + prettyJson(result) + "\n");

        }

        private void saveResult(byte[] result) throws IOException {
            File file = new File(context.getFilesDir(), "signatures.json");

            if (!file.exists()) {
                publishProgress("New signatures in blockchain available, please update! \n");
                saveJsonToFile(context, prettyJson(result), "signatures.json");
            } else if (!file.exists() | !areJsonsEqual(prettyJson(result),new File(context.getFilesDir(), "signatures.json"))) {
                publishProgress("New signatures in blockchain available, please update! \n");
                saveJsonToFile(context, prettyJson(result), "signatures.json");
            } else {
                publishProgress("No new signatures updates in blockchain available. \n");
            }
        }
    }


    private String prettyJson(final byte[] json) {
        return prettyJson(new String(json, StandardCharsets.UTF_8));
    }

    private String prettyJson(final String json) {
        var parsedJson = JsonParser.parseString(json);
        return gson.toJson(parsedJson);
    }

    public BufferedReader convertInputStreamToBufferedReader(InputStream inputStream) {
        return new BufferedReader(new InputStreamReader(inputStream));
    }

    public static void saveJsonToFile(Context context, String jsonString, String filename) {
        try {
            // 1. Parse JSON string
            JsonArray jsonArray = JsonParser.parseString(jsonString).getAsJsonArray();

            // 2. Get file path within the app's internal storage
            File file = new File(context.getFilesDir(), filename);

            // 3. Write JSON to file using Gson
            FileWriter writer = new FileWriter(file);
            new Gson().toJson(jsonArray, writer);
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
            // Handle exceptions appropriately (e.g., show error message to the user)
        }
    }

    public static BufferedReader convertStringToBufferedReader(String inputString) {
        try {
            // Convert string to InputStream
            InputStream inputStream = new ByteArrayInputStream(inputString.getBytes());

            // Wrap InputStream in InputStreamReader
            InputStreamReader inputStreamReader = new InputStreamReader(inputStream);

            // Wrap InputStreamReader in BufferedReader

            // Return the created BufferedReader
            return new BufferedReader(inputStreamReader);
        } catch (Exception e) {
            // Handle any exceptions
            e.printStackTrace();
            return null;
        }
    }
    public static InputStream convertStringToInputStream(String text) {
        // Convert the string to bytes
        byte[] bytes = text.getBytes();

        // Create a ByteArrayInputStream from the bytes
        return new ByteArrayInputStream(bytes);
    }
    public static boolean areJsonsEqual(String jsonString, File jsonFile) throws IOException {
        // 1. Parse JSON string from the input parameter
        JsonElement jsonElement1 = JsonParser.parseString(jsonString);

        // 2. Read and parse JSON from the file
        BufferedReader reader = new BufferedReader(new FileReader(jsonFile));
        JsonElement jsonElement2 = JsonParser.parseReader(reader);
        reader.close();

        // 3. Compare parsed JSON elements using Gson's deep equality check
        return jsonElement1.equals(jsonElement2);
    }
}